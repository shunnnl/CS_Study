> **📅 업로드 날짜**  
> 2025-07-20 
>
> **🗂 분류**  
> Data Structure
>
> **🔗 노션 링크**  
> [노션에서 보기](https://important-marquess-d42.notion.site/B-Tree-B-Tree-233a654e658a80d8adacda98c959fe89?pvs=74)

# B-Tree & B+Tree

## 1. B-Tree란?

- **균형 잡힌 M-Way 트리**
- 노드 하나에 여러 키와 자식 노드를 가질 수 있음
- **모든 노드(루트, 브랜치, 리프)에 key와 데이터 저장 가능**
- **탐색 시간은 O(logN)**
- 노드 삽입/삭제 시 자동으로 **트리의 균형 유지**

> 💡 **균형 트리**  
> 루트로부터 리프까지의 거리가 일정한 트리 구조를 뜻하며, 트리 성능을 안정적으로 유지한다.

<img width="551" height="266" alt="image" src="https://github.com/user-attachments/assets/5425be7f-45ef-4d7e-a502-5a96555fa74e" />


### ✅ 용어 정리

- **루트 노드**: 트리의 최상단
- **브랜치 노드**: 중간 단계 노드
- **리프 노드**: 데이터를 저장하는 가장 하단 노드

<img width="1024" height="300" alt="image" src="https://github.com/user-attachments/assets/899f6010-3f97-4891-9159-55316173c5b1" />

---

### 삽입

> 💡 삽입 로직 요약  
> 
> 1. 삽입할 key의 위치 탐색  
> 2. 해당 노드에 key 추가  
> 3. key 개수가 **최대 허용치 초과** 시  
>    - 노드를 **두 개로 분할(split)**  
>    - 중간 key는 부모 노드로 올림  
> 4. 필요하면 **재귀적으로 분할**하면서 트리 균형 유지

예시:
```
[10, 20]   →  [10, 20, 30] → 분할

→       [20]
        /   \
     [10]  [30]
```

---

### 삭제

> 💡 삭제 로직 요약  
> 
> 1. key가 있는 노드를 탐색  
> 2. 삭제 후 key 개수가 **최소 허용치 미만**이면  
>    - **형제 노드에서 key 빌리거나**  
>    - **병합(merge)** 해서 균형 유지  
> 3. 필요하면 부모 노드도 재조정

---

## 2. B+Tree란?

- **B-Tree의 확장 버전**
- **내부 노드에는 key만 저장** (데이터는 없음)
- **데이터는 오직 리프 노드에만 저장**
- **리프 노드끼리는 Linked List로 연결**
- 항상 리프까지 탐색 → 검색 성능 일정

<img width="1121" height="516" alt="image" src="https://github.com/user-attachments/assets/400e3895-8a6f-4874-8d94-9505ecfca6b0" />


---

### MySQL 인덱스와의 연관 (InnoDB)

- MySQL의 **InnoDB 스토리지 엔진은 B+Tree 기반의 클러스터형 인덱스 사용**
- 리프 노드에 **실제 레코드 주소(또는 데이터) 저장**
- 같은 레벨의 노드는 **Double Linked List**로 연결되어 있어 범위 탐색에 강력

> ✅ **클러스터형 인덱스 (Clustered Index)**  
> 인덱스의 리프 노드에 **실제 데이터가 함께 저장되는 인덱스**

> ✅ **Double Linked List**  
> 노드가 앞뒤 노드 모두를 가리키는 연결 리스트  
> 
> ```
> ←→ [A] ←→ [B] ←→ [C] ←→
> ```
> 
> - **앞으로도, 뒤로도 탐색 가능**  
> - **삭제, 삽입이 빠름** (단일 연결 리스트보다 유연)

---

## 3. B-Tree vs B+Tree 요약 비교표

| 항목             | B-Tree                 | B+Tree                            |
|------------------|------------------------|-----------------------------------|
| 데이터 저장       | 모든 노드              | 리프 노드만                       |
| 내부 노드 역할    | 탐색 + 저장            | 탐색 전용                         |
| 순차 탐색         | 느림                   | 빠름 (리프 연결)                  |
| 트리 높이         | 상대적으로 높음        | 낮음 (더 많은 key 수용 가능)     |
| 키 중복           | 없음                   | 있음 (모든 key가 리프에 존재)    |
| 링크드 리스트      | 없음                | 리프 노드 연결                 |

---

## 💡 B+Tree 장점 요약

1. **리프 노드 전용 데이터 저장 구조**  
   - 내부 노드에 **data가 없어서 작고 가벼움**  
   - → 한 노드에 더 많은 key 저장 가능 → **트리의 높이 ↓ → 탐색 깊이 감소**

2. **범위 검색과 정렬된 조회에 강력함**  
   - 리프 노드가 **연결되어 있어 연속 탐색 가능**  
   - 예: `id 30부터 80까지 출력` → 리프 노드 따라가기만 하면 됨  
   - B-Tree는 리프가 안 이어져서 일일이 찾아야 함

3. **캐시 효율 향상**  
   - 내부 노드가 작아서 메모리에 더 많은 인덱스 적재 가능  
   - → **디스크 접근 최소화**

---

## 4. 실무 활용 요약

### 🔹 RDBMS 인덱스 (MySQL InnoDB 등)

- **이유**: 데이터가 디스크에 저장되기 때문에, 디스크 접근 횟수를 줄이는 게 중요
- B+Tree는 **트리 높이가 낮고**, **순차 접근이 빠르며**, **범위 검색이 효율적**
- 클러스터형 인덱스를 통해 리프 노드에 실제 데이터까지 저장 가능 → **추가 접근 최소화**

---

### 🔹 파일 시스템 (NTFS, HFS+, ReFS 등)

- **이유**: 수많은 파일/디렉터리를 **정렬된 순서로 빠르게 탐색/검색**해야 함
- B+Tree의 리프 노드 연결 덕분에 **파일 이름 정렬, 범위 조회, 빠른 삽입/삭제**에 유리

---

### 🔹 NoSQL 일부 엔진 (예: RocksDB)

- **이유**: Write-heavy 환경에서도 **쓰기 효율성과 검색 성능의 균형**이 중요
- B+Tree는 범위 유지, 순차 기록 최적화 등에서 강점을 가짐

